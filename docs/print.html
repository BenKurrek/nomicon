<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nearnomicon</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Implementation details of the NearProtocol client">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="mermaid.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index.html">Introduction</a></li><li><a href="Network/Network.html"><strong aria-hidden="true">1.</strong> Network</a></li><li><ol class="section"><li><a href="Network/PeerManagement.html"><strong aria-hidden="true">1.1.</strong> Peer Management</a></li><li><a href="Network/TransactionPropagation.html"><strong aria-hidden="true">1.2.</strong> Transaction Propagation</a></li><li><a href="Network/Consensus.html"><strong aria-hidden="true">1.3.</strong> Consensus</a></li></ol></li><li><a href="Nightshade/Nightshade.html"><strong aria-hidden="true">2.</strong> Nightshade</a></li><li><ol class="section"><li><a href="Nightshade/State.html"><strong aria-hidden="true">2.1.</strong> State</a></li><li><a href="Nightshade/VerifyError.html"><strong aria-hidden="true">2.2.</strong> State Verifying Errors</a></li><li><a href="Nightshade/Cryptography.html"><strong aria-hidden="true">2.3.</strong> Cryptography</a></li></ol></li><li><a href="DataStructures/DataStructures.html"><strong aria-hidden="true">3.</strong> Data Structures</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Nearnomicon</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-nearnomicon" id="the-nearnomicon"><h1>The Nearnomicon</h1></a>
<p>Nearnomicon contains the following information about the components of the NearProtocol client, with the goal to help
with the collaboration:</p>
<ul>
<li>High-level overview of the components and how they interact, including APIs;</li>
<li>Data-structures;</li>
<li>Things that are not yet implemented or replaced with temporary solutions;</li>
<li>Assumptions that each component makes.</li>
</ul>
<a class="header" href="#network" id="network"><h1>Network</h1></a>
<p>The network crate has two levels of abstractions:</p>
<ol>
<li><strong>Peer management</strong> is a low-level code that only works with discovering peers and connecting to them. It is not domain-specific, meaning it does not care about the content of the messages that it receives from the peers;</li>
<li><strong>Protocol</strong> is a higher-level code that understands the content of incoming and outgoing messages and communicates them with the corresponding parts of the infrastructure.</li>
</ol>
<a class="header" href="#current-state" id="current-state"><h2>Current state</h2></a>
<p>Our current implementation of the network is the minimal one for running nodes locally, on AWS, or in integration tests.
It contains the following functionality:</p>
<ul>
<li><strong>Peer discovery through the gossip.</strong> Peers periodically exchange information with each other about other peers that they know allowing all peers to gradually discover each other;</li>
<li><strong>Booting from the boot nodes.</strong> Peers start discovering of other peers by initially connecting to the boot nodes;</li>
<li><strong>Handshake.</strong> Peers that establish the connection with each other are required to perform a handshake that involves exchanging certain information, like information about other peers;</li>
<li><strong>Unique connection.</strong> We guarantee that there is at most one connection between two peers, by breaking a tie when they try to connect to each other simultaneously;</li>
<li><strong>Timeouts.</strong> Certain operations, like establishing a connection or performing a handshake are limited by a timeout;</li>
<li><strong>Reconnection.</strong> Peers that have some connections dropped will try to re-establish them after a certain period of time.</li>
</ul>
<p>The following functionality is not implemented yet:</p>
<ul>
<li><strong>Relays.</strong> The peers that are behind the NAT cannot have a direct communication and have to use relays. Our current code does not implement that;</li>
<li><strong>Broadcasting.</strong> We need a broadcasting for announcements over the network;</li>
<li><strong>Encryption.</strong> Currently our messages are not encrypted;</li>
<li><strong>Verification.</strong> During the handshake we should verify that the other peer is not an impostor, by verifying their signed handshake;</li>
<li><strong>Connection limit.</strong> We need to limit the number of connections a single peer can have. When we try to establish a connection with a maxed-out boot node it should redirect us to other nodes;</li>
<li><strong>Tight coupling between gossip and relaying.</strong> Our consensus algorithms use gossip, since we want them to adversary-proof the relaying should be adversary-proof too.</li>
<li><strong>DNS.</strong> DNS resolution.</li>
</ul>
<a class="header" href="#peer-management" id="peer-management"><h1>Peer Management</h1></a>
<p>As discussed before, peer management takes care of peers and does not work with the content of the
messages sent between the peers.</p>
<p>Each peer in peer management is represented by a state-machine, represented by <code>Peer</code> object. Peer can then be in
multiple states:</p>
<ul>
<li><strong>Unconnected</strong> -- we know that peer's info but we have not established a connection yet;</li>
<li><strong>Connecting</strong> -- we are in process of connecting to a peer;</li>
<li><strong>Connected</strong> -- we have sent a handshake and are waiting for a response handshake;</li>
<li><strong>Ready</strong> -- we are exchanging domain-specific messages with the peer, like block announcements, gossip, etc;</li>
<li><strong>Incoming</strong> -- someone, we do not know who, has established a incoming connection with us. We are waiting for a handshake;</li>
</ul>
<p>Here is an example of Alice establishing connection with a boot node, Bob.</p>
<div class="mermaid">
sequenceDiagram
    Note over Alice: Alice has Bob's state as Unconnected
    Alice->>Alice: Connection timeout expires
    Note over Alice: Alice switches Bob's state to Connecting
    Alice->>+Bob: Opening connection
    Note over Alice,Bob: Bob adds a peer with the state Incoming. Alice switches Bob's state to Connected
    Alice->>Bob: Sending handshake
    Note over Bob: Bob switches Alice's state to Ready.
    Bob->>-Alice: Replying with handshake
    Note over Alice: Alice switches Bob's state to Ready.
</div>
<a class="header" href="#transaction-propagation" id="transaction-propagation"><h1>Transaction propagation</h1></a>
<p>It is essential for all nodes participating in the network having well synchronized their sets of unused transactions, and have an efficient mechanism to propagate them without decreasing transactions throughput. When a transaction is included in a block, every participant should forget(remove) this transaction.</p>
<a class="header" href="#strategies" id="strategies"><h2>Strategies</h2></a>
<ul>
<li>
<p>Dummy Strategy: Each participant has the set of transactions of every other participant from its point of view. This set is always a subset of the real set of transactions. When Alice and Bob want to sync their transactions, Alice will only send to Bob tx that she believes he doesn't have. After sending the transactions she will update her believes from Bob set.</p>
<ul>
<li>PRO: It is easy to implement. <strong>(We will use this strategy for alphanet)</strong></li>
<li>CONS: We are sending the same transactions many times overloading the network.</li>
<li>Details: Instead of keeping a set per participant explicitly, we will add a bitmask to each transaction of size the number of participants in the network. (What if participants goes in-n-out?)</li>
</ul>
</li>
<li>
<p>Bloom Filters:</p>
</li>
<li>
<p><a href="https://medium.com/harmony-one/block-syncing-in-1-36s-with-harmonys-adaptive-ida-protocol-de5da398569e">Block Syncing in 1.36s with Harmony’s Adaptive IDA Protocol</a></p>
</li>
</ul>
<a class="header" href="#blockchain-protocol-overview" id="blockchain-protocol-overview"><h1>Blockchain protocol overview</h1></a>
<a class="header" href="#consensus" id="consensus"><h2>Consensus</h2></a>
<p>Participants will try to agree on the next block, to do that each participant will propose a block. <code>Proposal</code> in this diagram is the hash of the proposed block.</p>
<div class="mermaid">
sequenceDiagram
    participant Mempool
    participant Nightshade
    participant Network
    Mempool->>Nightshade: Send RESET signal.
    Note over Nightshade: Start running consensus on confirmed proposals.
    loop Do for every other participant async.
        Nightshade->>Network: Gossip signed proposal [1].
        Network->>Nightshade: Receive signed proposal [2].
        Nightshade->>Mempool: Request confirmation.
        Mempool-->Network: Sync mempool until this proposal is valid [4].
        Mempool->>Nightshade: Send confirmation.
        Note over Nightshade: Set proposal as confirmed.
    end
    loop Consensus not achieved
        Nightshade->>Network: Gossip current state.
        Network->>Nightshade: Receive state update.
        alt missing proposal
            Nightshade->>Network: Request signed proposal [3].
        else achieve consensus
            Note over Nightshade: Send consensus.
        end
    end
</div>
<p>Notes:</p>
<ul>
<li>[1] This can fail. Network fails or participant is offline.</li>
<li>[2] If we fail to receive a proposal and we need it later for consensus it will be requested in [3]</li>
<li>[3] Request missing proposal.</li>
<li>[4] A <code>proposal</code> is valid if the block proposed can be fetched from the mempool.</li>
</ul>
<a class="header" href="#nightshade" id="nightshade"><h1>Nightshade</h1></a>
<p><strong>Nightshade</strong> is the Byzantine-fault tolerant consensus protocol used at the core of <em>NEAR PROTOCOL</em>.</p>
<p>Important features:</p>
<ul>
<li>Tolerates up to \( \frac 1 3 \) Byzantine participants.</li>
<li>It is not DAG-Based and the space complexity growth linear with respect to the number of participants.</li>
<li>It only requires from 3 to 4 rounds of communication (where one round involves \( O(n) \) participants hearing from \( O(n) \) participants via the gossip network, so total of \( O(n^2) \) communication).
<ul>
<li>This is not true when malicious actor adaptatively try to break liveness.</li>
<li>We need to measure properly expected number of rounds if we change the gossiping mechanism.</li>
</ul>
</li>
<li>It is guaranteed that after one honest participant commits to some value, other honest participants will not commit to a different value.</li>
</ul>
<a class="header" href="#the-prototocol" id="the-prototocol"><h2>The Prototocol</h2></a>
<p>This protocol allows <code>N</code> participants achieving consensus on one proposal. At the beginning of the protocol, each participant makes a proposal (proposals can coincide) and gossip it through the network.</p>
<p>Each participant (or node) maintain the prefered proposal in the form of a triplet:</p>
<p><code>(primary confidence, outcome, secondary confidence)</code></p>
<p>They have for every proposal a confidence (which is not explicetily stored). At the begining of the protocol, every proposal have confidence 0. The triplet stands for:</p>
<ul>
<li><code>primary confidence</code>: Highest confidence among all proposals.</li>
<li><code>outcome</code>: Proposal with highest confidence.</li>
<li><code>secondary confidence</code>: Highest confidence among all proposals differents from <code>outcome</code> (It can be equal to <code>primary confidence</code>).</li>
</ul>
<p>Triplet with highest primary_confidence is prefered, highest secondary confidence is used as first tie-breeaker, and order defined between outcomes is used as final tie-breaker. Among all seen triplets participants state will be the prefered triplet. At the begining of the protocol each node state is (0, v_i, 0), where v_i is its own proposal.</p>
<p>It is important to define a complete and unbiased order for proposals so <code>outcome</code> can be uniquely chosen when there are several values with the same highest confidence. In the current implementation each participant have an ID, and their proposal has the form of the tuple <code>(ID, value)</code>. <code>value</code> can be anything (for example the hash of a block to append in the chain). This works if participants ID are assigned randomly without malicious actor having the chance to bias this assignment.</p>
<p>Using a gossiping mechanism each node shares it current state with other nodes, and after collecting the same prefered state from more than \( \frac 2 3 \)  of the total number of participants, the confidence on this <code>outcome</code> is increased by 1 and the triplet transfroms from <code>(A, O, B)</code> into <code>(A + 1, O, B)</code>.</p>
<p>Participants will update its own state after receiving triplets from other participants if the proposed triplet is better than the current triplet, or second highest confidence can increase. If current triplet is <code>(3, A, 1)</code> and a node receive triplet <code>(2, B, 0)</code> then the next state will be <code>(3, A, 2)</code> (Secondary confidence is set to two). We will see specific details about state <a href="Nightshade/State.html">later</a>.</p>
<a class="header" href="#proofs-secure-and-verifiable-triplets" id="proofs-secure-and-verifiable-triplets"><h2>Proofs. Secure and verifiable triplets</h2></a>
<p>In order for a triplet to be valid, it must carry a proof for both confidences (primary and secondary). Each triplet endorsed by some participant will be signed using BLS signature scheme. This scheme, despite being slow to sign/verify, allows to aggregate signatures fast and verify easily aggregated signatures.</p>
<p>The proof for primary confidence for a triplet <code>(A, O, B)</code> consist on the aggregated BLS signature from more than \( \frac 2 3 \) of the participants on triplet <code>(A - 1, O, B)</code> and the mask that points who were the participants who signed this message. Triplet with zero primary confidence don't require such proof. Since public keys are ... well, public, everyone having the aggregated signature and the mask can verify that the proof is correct.</p>
<p>The proof for secondary confidence is the proof for primary confidence of the state that was responsible of the last secodary confidence update.</p>
<a class="header" href="#commit" id="commit"><h2>Commit</h2></a>
<p>Participants will commit to some outcome after its primary confidence exceed the secondary confidence by 3 or more margin. Read <a href="https://www.overleaf.com/read/snswgqkjvwvy">Nightshade Whitepaper</a> to see why this gap of 3 is enough to guarantee that after some node commit to a value, no other node will commit to a different value.</p>
<p>Even if a node have enough evidence to commit soon for some outcome <code>O</code> it must remain participating in the protocol, until at least \( \frac 2 3 \) of other nodes have committed too. Early exit for the protocol disallow remaining participants from committing, since they will stop receiving updates from some participants.</p>
<p>It is also necessary that participants who have already committed, not only gossip its own state but keep updating it from external gossip as established in the protocol (even if they transition to a non commit state).</p>
<a class="header" href="#non-blocking-state-example" id="non-blocking-state-example"><h3>Non blocking state example</h3></a>
<p>This is an example of why participants must follow the protcol even after committing.</p>
<ul>
<li>Participant 1, State <code>(4, A, 1)</code>: She can already commit to outcome A.</li>
<li>Participant 2, State <code>(2, B, 0)</code>: He can't get from this state to <code>(4, A, 1)</code>, because after changing outcome its secondary confidence will be always grater than or equal to 2.</li>
<li>Participant 1, State <code>(4, A, 2)</code>: She must update the secondary confidence after receiving state update from participant 2. Notice that after doing that she has not a committing triplet. But <strong>Nightshade</strong> guarantees that it is not possible for them committing to a different outcome.</li>
<li>Both participants will commit on triplet on outcome A after arriving at state <code>(5, A, 2)</code>.</li>
</ul>
<a class="header" href="#details" id="details"><h2>Details</h2></a>
<ul>
<li>This protocol works with less than \( \frac 1 3 \) of byzantine participants.</li>
<li>We assume that a message sent between a pair of non-byzantines peers will arrive on a finite time (maybe after resending it).</li>
<li>Since the expected primary confidence to commit should be no much larger than 3, if at some point the confidence for some outcome is greater than \( (C &gt; 5) \) and it have not committed yet, participants know almost surely that something is not going well.</li>
<li>Liveness is an issue in the current protocol, since malicious actors can stall the protocol creating a metastable situation. TODO: Describe how they can move the consensus toward such situation and how we address this problem (wait randoms delay without updating the state for message of several participants).</li>
</ul>
<a class="header" href="#byzantine-behaviour" id="byzantine-behaviour"><h2>Byzantine behaviour</h2></a>
<ul>
<li>Failing in unexpected ways. <em>This is not penalized</em>. It is expected that nodes go in-n-out of the network: because of network failures, shutting down the node, hardware issues and more.</li>
<li>Deviating from the protocol. <em>This should be penalized whenever detected and concrete evidence exists</em>.</li>
</ul>
<a class="header" href="#state" id="state"><h1>State</h1></a>
<p>The state of each participant is the triplet:</p>
<p><code>(Primary Confidence, Outcome, Secondary Confidence)</code></p>
<p>TODO:</p>
<ul>
<li>Describe how <code>update_state</code> (inside <code>Nigthshade</code> works). Assumptions. Examples and corner cases</li>
<li>When we receive a state update from a participant that we don't have its payload we discard it (maybe we don't wanth to do this)</li>
<li>All posible ways an authority can become an adversary from the point of view of other authority (currently one authority can't frame another as an adversary, but maybe is something we would like to add)</li>
</ul>
<a class="header" href="#state-errors" id="state-errors"><h1>State errors</h1></a>
<p>This cover all possible way in which a state verification might fail. If the verification fails the participant sending this state must be considered adversarial (since he signs the gossip containing this state).</p>
<pre><code class="language-rust ignored">pub enum NSVerifyErr {
    // Bad formed triplet. Primary confidence must be equal or greater than secondary confidence.
    // Both confidence must be non negative integers.
    InvalidTriplet,
    // Bls signature provided doesn't match against bls public key + triplet data
    InvalidBlsSignature,
    // Proof doesn't contain enough signatures to increase confidence
    MissingSignatures,
    // Proofs provided are incorrect. Aggregated signature doesn't match with aggregated public keys + triplet data
    InvalidProof,
    // The proof for the current triplet is wrong. Confidence/Outcomes are not valid.
    InconsistentState,
    // There is a proof for a triplet that doesn't require it.
    ExtraProof,
    // Triplet requires a proof that is not present
    MissingProof,
}
</code></pre>
<a class="header" href="#cryptography" id="cryptography"><h1>Cryptography</h1></a>
<p>Participant should sign every message they sent through the network using its public key.</p>
<a class="header" href="#a-hrefhttpsgithubcomexonumexonum_sodiumoxideed25519a" id="a-hrefhttpsgithubcomexonumexonum_sodiumoxideed25519a"><h2><a href="https://github.com/exonum/exonum_sodiumoxide">ed25519</a></h2></a>
<p>This scheme is used to sign gossip in the network layer. This are fast verifiable signatures.</p>
<ul>
<li>Gossips with invalid signatures are discarded</li>
<li>Gossips with valid signatures are processed. If they contain invalid content (deviating from the protocol in anyway), the signature and the content of the gossip is used as evidence for the sender as malicious actor.</li>
</ul>
<a class="header" href="#a-hrefhttpsenwikipediaorgwikibonehe28093lynne28093shachamblsa" id="a-hrefhttpsenwikipediaorgwikibonehe28093lynne28093shachamblsa"><h2><a href="https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham">BLS</a></h2></a>
<p>BLS is used to sign triplets in <a href="Nightshade/Nightshade/Nightshade.html">Nightshade Consensus</a>.</p>
<ul>
<li>Each triplet contain the BLS signature of the holder.</li>
<li>The proof for the triplets are the aggregated signatures of the participants.</li>
<li>Useful because it allow us to run a <a href="https://en.wikipedia.org/wiki/Threshold_cryptosystem">threshold scheme</a>.</li>
<li>Slow signing/verifying. TODO: Link our benchmark.</li>
</ul>
<a class="header" href="#data-structures" id="data-structures"><h1>Data Structures</h1></a>
<p>The following is a list of standard data-structures.</p>
<a class="header" href="#transaction" id="transaction"><h2>Transaction</h2></a>
<pre><code class="language-rust ignored">struct Transaction {
    originator: AccountId,
    receiver: AccountId,
    nonce: u64,
    method_name: Vec&lt;u8&gt;,
    args: Vec&lt;u8&gt;,
    amount: Balance,
}

struct ReceiptBlock {
    header: SignedShardBlockHeader,
    path: Vec&lt;Hash&gt;,
    receipts: Vec&lt;Receipt&gt;,
}
</code></pre>
<a class="header" href="#shard" id="shard"><h2>Shard</h2></a>
<pre><code class="language-rust ignored">struct ShardBlockHeader {
    parent: Hash,
    index: u64,
    shard_id: u64,
    // State trie
    merkle_root_state: Hash,
    // Transactions Trie
    merkle_root_tx: Hash,
    // Receipt blocks Trie
    merkle_root_receipt: Hash,
    // Transaction result Trie
    merkle_root_tx_result: Hash,
    // Receipt result Trie
    merkle_root_receipt_result: Hash,
}

struct tShardBlockBody {
    receipts: Vec&lt;ReceiptBlock&gt;,
    transactions: Vec&lt;SignedTransaction&gt;,
}

struct SignedShardBlock {
    header: ShardHeader,
    body: ShardBody,
    signature: BLS,
    authority_mask: Vec&lt;bool&gt;,
}

// ShardBlock Extra (Index?)
// 	TransactionAddress
// 		BlockId
// 		Index
// 	Receipts
// 		HashMap&lt;ShardId, Vec&lt;Receipt&gt;&gt;
// 	Hash -&gt; Transaction/Receipt Result // or should we put into two Vec that align with transactions/receipts?
// 		Status (Completed, Failed)
// 		Gas
// 		Receipts ids of receipts
// 		Logs


struct ShardClient {
    chain: Chain&lt;SignedShardBlock&gt;,
    runtime: Runtime,
    state: StateDb,
}
    
fn to_shard_receipt_blocks(ShardBlockExtra) -&gt; Vec&lt;ReceiptBlock&gt; { 
   
}
</code></pre>
<a class="header" href="#beacon" id="beacon"><h2>Beacon</h2></a>
<pre><code class="language-rust ignored">//System extension to every contract/account
//	send_money(to, value)
//	swap_keys(old_public_key, new_public_key)
//
//Transaction(orignator=me, receiver=account, method=”system::swap_keys”, args={...})
//
//Transaction(originator=me, receiver=system, method=send_money, args={...})
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
