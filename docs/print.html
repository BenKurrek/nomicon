<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nearnomicon</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Implementation details of the NearProtocol client">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="mermaid.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index.html">Introduction</a></li><li><a href="Network/Network.html"><strong aria-hidden="true">1.</strong> Network</a></li><li><ol class="section"><li><a href="Network/PeerManagement.html"><strong aria-hidden="true">1.1.</strong> Peer Management</a></li><li><a href="Network/TransactionPropagation.html"><strong aria-hidden="true">1.2.</strong> Transaction Propagation</a></li><li><a href="Network/Consensus.html"><strong aria-hidden="true">1.3.</strong> Consensus</a></li></ol></li><li><a href="Nightshade/Nightshade.html"><strong aria-hidden="true">2.</strong> Nightshade</a></li><li><ol class="section"><li><a href="Nightshade/State.html"><strong aria-hidden="true">2.1.</strong> State</a></li><li><a href="Nightshade/VerifyError.html"><strong aria-hidden="true">2.2.</strong> State Verifying Errors</a></li><li><a href="Nightshade/Cryptography.html"><strong aria-hidden="true">2.3.</strong> Cryptography</a></li></ol></li><li><a href="DataStructures/DataStructures.html"><strong aria-hidden="true">3.</strong> Data Structures</a></li><li><a href="Mempool/Mempool.html"><strong aria-hidden="true">4.</strong> Mempool</a></li><li><a href="BlockChain/BlockChain.html"><strong aria-hidden="true">5.</strong> Block Chain</a></li><li><ol class="section"><li><a href="BlockChain/Construction.html"><strong aria-hidden="true">5.1.</strong> Construction</a></li><li><a href="BlockChain/BlockStructure.html"><strong aria-hidden="true">5.2.</strong> Block Structure</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Nearnomicon</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-nearnomicon" id="the-nearnomicon"><h1>The Nearnomicon</h1></a>
<p>Nearnomicon contains the following information about the components of the NearProtocol client, with the goal to help
with the collaboration:</p>
<ul>
<li>High-level overview of the components and how they interact, including APIs;</li>
<li>Data-structures;</li>
<li>Things that are not yet implemented or replaced with temporary solutions;</li>
<li>Assumptions that each component makes.</li>
</ul>
<a class="header" href="#network" id="network"><h1>Network</h1></a>
<p>The network crate has two levels of abstractions:</p>
<ol>
<li><strong>Peer management</strong> is a low-level code that only works with discovering peers and connecting to them. It is not domain-specific, meaning it does not care about the content of the messages that it receives from the peers;</li>
<li><strong>Protocol</strong> is a higher-level code that understands the content of incoming and outgoing messages and communicates them with the corresponding parts of the infrastructure.</li>
</ol>
<a class="header" href="#current-state" id="current-state"><h2>Current state</h2></a>
<p>Our current implementation of the network is the minimal one for running nodes locally, on AWS, or in integration tests.
It contains the following functionality:</p>
<ul>
<li><strong>Peer discovery through the gossip.</strong> Peers periodically exchange information with each other about other peers that they know allowing all peers to gradually discover each other;</li>
<li><strong>Booting from the boot nodes.</strong> Peers start discovering of other peers by initially connecting to the boot nodes;</li>
<li><strong>Handshake.</strong> Peers that establish the connection with each other are required to perform a handshake that involves exchanging certain information, like information about other peers;</li>
<li><strong>Unique connection.</strong> We guarantee that there is at most one connection between two peers, by breaking a tie when they try to connect to each other simultaneously;</li>
<li><strong>Timeouts.</strong> Certain operations, like establishing a connection or performing a handshake are limited by a timeout;</li>
<li><strong>Reconnection.</strong> Peers that have some connections dropped will try to re-establish them after a certain period of time.</li>
</ul>
<p>The following functionality is not implemented yet:</p>
<ul>
<li><strong>Relays.</strong> The peers that are behind the NAT cannot have a direct communication and have to use relays. Our current code does not implement that;</li>
<li><strong>Broadcasting.</strong> We need a broadcasting for announcements over the network;</li>
<li><strong>Encryption.</strong> Currently our messages are not encrypted;</li>
<li><strong>Verification.</strong> During the handshake we should verify that the other peer is not an impostor, by verifying their signed handshake;</li>
<li><strong>Connection limit.</strong> We need to limit the number of connections a single peer can have. When we try to establish a connection with a maxed-out boot node it should redirect us to other nodes;</li>
<li><strong>Tight coupling between gossip and relaying.</strong> Our consensus algorithms use gossip, since we want them to adversary-proof the relaying should be adversary-proof too.</li>
<li><strong>DNS.</strong> DNS resolution.</li>
</ul>
<a class="header" href="#peer-management" id="peer-management"><h1>Peer Management</h1></a>
<p>As discussed before, peer management takes care of peers and does not work with the content of the
messages sent between the peers.</p>
<p>Each peer in peer management is represented by a state-machine, represented by <code>Peer</code> object. Peer can then be in
multiple states:</p>
<ul>
<li><strong>Unconnected</strong> -- we know that peer's info but we have not established a connection yet;</li>
<li><strong>Connecting</strong> -- we are in process of connecting to a peer;</li>
<li><strong>Connected</strong> -- we have sent a handshake and are waiting for a response handshake;</li>
<li><strong>Ready</strong> -- we are exchanging domain-specific messages with the peer, like block announcements, gossip, etc;</li>
<li><strong>Incoming</strong> -- someone, we do not know who, has established a incoming connection with us. We are waiting for a handshake;</li>
</ul>
<p>Here is an example of Alice establishing connection with a boot node, Bob.</p>
<div class="mermaid">
sequenceDiagram
    Note over Alice: Alice has Bob's state as Unconnected
    Alice->>Alice: Connection timeout expires
    Note over Alice: Alice switches Bob's state to Connecting
    Alice->>+Bob: Opening connection
    Note over Alice,Bob: Bob adds a peer with the state Incoming. Alice switches Bob's state to Connected
    Alice->>Bob: Sending handshake
    Note over Bob: Bob switches Alice's state to Ready.
    Bob->>-Alice: Replying with handshake
    Note over Alice: Alice switches Bob's state to Ready.
</div>
<a class="header" href="#transaction-propagation" id="transaction-propagation"><h1>Transaction propagation</h1></a>
<p>It is essential for all nodes participating in the network having well synchronized their sets of unused transactions, and have an efficient mechanism to propagate them without decreasing transactions throughput. When a transaction is included in a block, every participant should forget(remove) this transaction.</p>
<a class="header" href="#strategies" id="strategies"><h2>Strategies</h2></a>
<ul>
<li>
<p>Dummy Strategy: Each participant has the set of transactions of every other participant from its point of view. This set is always a subset of the real set of transactions. When Alice and Bob want to sync their transactions, Alice will only send to Bob tx that she believes he doesn't have. After sending the transactions she will update her believes from Bob set.</p>
<ul>
<li>PRO: It is easy to implement. <strong>(We will use this strategy for alphanet)</strong></li>
<li>CONS: We are sending the same transactions many times overloading the network.</li>
<li>Details: Instead of keeping a set per participant explicitly, we will add a bitmask to each transaction of size the number of participants in the network. (What if participants goes in-n-out?)</li>
</ul>
</li>
<li>
<p>Bloom Filters:</p>
</li>
<li>
<p><a href="https://medium.com/harmony-one/block-syncing-in-1-36s-with-harmonys-adaptive-ida-protocol-de5da398569e">Block Syncing in 1.36s with Harmony’s Adaptive IDA Protocol</a></p>
</li>
</ul>
<a class="header" href="#blockchain-protocol-overview" id="blockchain-protocol-overview"><h1>Blockchain protocol overview</h1></a>
<a class="header" href="#consensus" id="consensus"><h2>Consensus</h2></a>
<p>Participants will try to agree on the next block, to do that each participant will propose a block. <code>Proposal</code> in this diagram is the hash of the proposed block.</p>
<div class="mermaid">
sequenceDiagram
    participant Mempool
    participant Nightshade
    participant Network
    Mempool->>Nightshade: Send RESET signal.
    Note over Nightshade: Start running consensus on confirmed proposals.
    loop Do for every other participant async.
        Nightshade->>Network: Gossip signed proposal [1].
        Network->>Nightshade: Receive signed proposal [2].
        Nightshade->>Mempool: Request confirmation.
        Mempool-->Network: Sync mempool until this proposal is valid [4].
        Mempool->>Nightshade: Send confirmation.
        Note over Nightshade: Set proposal as confirmed.
    end
    loop Consensus not achieved
        Nightshade->>Network: Gossip current state.
        Network->>Nightshade: Receive state update.
        alt missing proposal
            Nightshade->>Network: Request signed proposal [3].
        else achieve consensus
            Note over Nightshade: Send consensus.
        end
    end
</div>
<p>Notes:</p>
<ul>
<li>[1] This can fail. Network fails or participant is offline.</li>
<li>[2] If we fail to receive a proposal and we need it later for consensus it will be requested in [3]</li>
<li>[3] Request missing proposal.</li>
<li>[4] A <code>proposal</code> is valid if the block proposed can be fetched from the mempool.</li>
</ul>
<a class="header" href="#nightshade" id="nightshade"><h1>Nightshade</h1></a>
<p><strong>Nightshade</strong> is the Byzantine-fault tolerant consensus protocol used at the core of <em>NEAR PROTOCOL</em>.</p>
<p>Important features:</p>
<ul>
<li>Tolerates up to \( \frac 1 3 \) Byzantine participants.</li>
<li>It is not DAG-Based and the space complexity growth linear with respect to the number of participants.</li>
<li>It only requires from 3 to 4 rounds of communication (where one round involves \( O(n) \) participants hearing from \( O(n) \) participants via the gossip network, so total of \( O(n^2) \) communication).
<ul>
<li>This is not true when malicious actor adaptatively try to break liveness.</li>
<li>We need to measure properly expected number of rounds if we change the gossiping mechanism.</li>
</ul>
</li>
<li>It is guaranteed that after one honest participant commits to some value, other honest participants will not commit to a different value.</li>
</ul>
<a class="header" href="#the-prototocol" id="the-prototocol"><h2>The Prototocol</h2></a>
<p>This protocol allows <code>N</code> participants achieving consensus on one proposal. At the beginning of the protocol, each participant makes a proposal (proposals can coincide) and gossip it through the network.</p>
<p>Each participant (or node) maintain the prefered proposal in the form of a triplet:</p>
<p><code>(primary confidence, outcome, secondary confidence)</code></p>
<p>They have for every proposal a confidence (which is not explicetily stored). At the begining of the protocol, every proposal have confidence 0. The triplet stands for:</p>
<ul>
<li><code>primary confidence</code>: Highest confidence among all proposals.</li>
<li><code>outcome</code>: Proposal with highest confidence.</li>
<li><code>secondary confidence</code>: Highest confidence among all proposals differents from <code>outcome</code> (It can be equal to <code>primary confidence</code>).</li>
</ul>
<p>Triplet with highest primary_confidence is prefered, highest secondary confidence is used as first tie-breeaker, and order defined between outcomes is used as final tie-breaker. Among all seen triplets participants state will be the prefered triplet. At the begining of the protocol each node state is (0, v_i, 0), where v_i is its own proposal.</p>
<p>It is important to define a complete and unbiased order for proposals so <code>outcome</code> can be uniquely chosen when there are several values with the same highest confidence. In the current implementation each participant have an ID, and their proposal has the form of the tuple <code>(ID, value)</code>. <code>value</code> can be anything (for example the hash of a block to append in the chain). This works if participants ID are assigned randomly without malicious actor having the chance to bias this assignment.</p>
<p>Using a gossiping mechanism each node shares it current state with other nodes, and after collecting the same prefered state from more than \( \frac 2 3 \)  of the total number of participants, the confidence on this <code>outcome</code> is increased by 1 and the triplet transfroms from <code>(A, O, B)</code> into <code>(A + 1, O, B)</code>.</p>
<p>Participants will update its own state after receiving triplets from other participants if the proposed triplet is better than the current triplet, or second highest confidence can increase. If current triplet is <code>(3, A, 1)</code> and a node receive triplet <code>(2, B, 0)</code> then the next state will be <code>(3, A, 2)</code> (Secondary confidence is set to two). We will see specific details about state <a href="Nightshade/State.html">later</a>.</p>
<a class="header" href="#proofs-secure-and-verifiable-triplets" id="proofs-secure-and-verifiable-triplets"><h2>Proofs. Secure and verifiable triplets</h2></a>
<p>In order for a triplet to be valid, it must carry a proof for both confidences (primary and secondary). Each triplet endorsed by some participant will be signed using BLS signature scheme. This scheme, despite being slow to sign/verify, allows to aggregate signatures fast and verify easily aggregated signatures.</p>
<p>The proof for primary confidence for a triplet <code>(A, O, B)</code> consist on the aggregated BLS signature from more than \( \frac 2 3 \) of the participants on triplet <code>(A - 1, O, B)</code> and the mask that points who were the participants who signed this message. Triplet with zero primary confidence don't require such proof. Since public keys are ... well, public, everyone having the aggregated signature and the mask can verify that the proof is correct.</p>
<p>The proof for secondary confidence is the proof for primary confidence of the state that was responsible of the last secodary confidence update.</p>
<a class="header" href="#commit" id="commit"><h2>Commit</h2></a>
<p>Participants will commit to some outcome after its primary confidence exceed the secondary confidence by 3 or more margin. Read <a href="https://www.overleaf.com/read/snswgqkjvwvy">Nightshade Whitepaper</a> to see why this gap of 3 is enough to guarantee that after some node commit to a value, no other node will commit to a different value.</p>
<p>Even if a node have enough evidence to commit soon for some outcome <code>O</code> it must remain participating in the protocol, until at least \( \frac 2 3 \) of other nodes have committed too. Early exit for the protocol disallow remaining participants from committing, since they will stop receiving updates from some participants.</p>
<p>It is also necessary that participants who have already committed, not only gossip its own state but keep updating it from external gossip as established in the protocol (even if they transition to a non commit state).</p>
<a class="header" href="#non-blocking-state-example" id="non-blocking-state-example"><h3>Non blocking state example</h3></a>
<p>This is an example of why participants must follow the protcol even after committing.</p>
<ul>
<li>Participant 1, State <code>(4, A, 1)</code>: She can already commit to outcome A.</li>
<li>Participant 2, State <code>(2, B, 0)</code>: He can't get from this state to <code>(4, A, 1)</code>, because after changing outcome its secondary confidence will be always grater than or equal to 2.</li>
<li>Participant 1, State <code>(4, A, 2)</code>: She must update the secondary confidence after receiving state update from participant 2. Notice that after doing that she has not a committing triplet. But <strong>Nightshade</strong> guarantees that it is not possible for them committing to a different outcome.</li>
<li>Both participants will commit on triplet on outcome A after arriving at state <code>(5, A, 2)</code>.</li>
</ul>
<a class="header" href="#details" id="details"><h2>Details</h2></a>
<ul>
<li>This protocol works with less than \( \frac 1 3 \) of byzantine participants.</li>
<li>We assume that a message sent between a pair of non-byzantines peers will arrive on a finite time (maybe after resending it).</li>
<li>Since the expected primary confidence to commit should be no much larger than 3, if at some point the confidence for some outcome is greater than \( (C &gt; 5) \) and it have not committed yet, participants know almost surely that something is not going well.</li>
<li>Liveness is an issue in the current protocol, since malicious actors can stall the protocol creating a metastable situation. TODO: Describe how they can move the consensus toward such situation and how we address this problem (wait randoms delay without updating the state for message of several participants).</li>
</ul>
<a class="header" href="#byzantine-behaviour" id="byzantine-behaviour"><h2>Byzantine behaviour</h2></a>
<ul>
<li>Failing in unexpected ways. <em>This is not penalized</em>. It is expected that nodes go in-n-out of the network: because of network failures, shutting down the node, hardware issues and more.</li>
<li>Deviating from the protocol. <em>This should be penalized whenever detected and concrete evidence exists</em>.</li>
</ul>
<a class="header" href="#state" id="state"><h1>State</h1></a>
<p>The state of each participant is the triplet:</p>
<p><code>(Primary Confidence, Outcome, Secondary Confidence)</code></p>
<p>TODO:</p>
<ul>
<li>Describe how <code>update_state</code> (inside <code>Nigthshade</code> works). Assumptions. Examples and corner cases</li>
<li>When we receive a state update from a participant that we don't have its payload we discard it (maybe we don't wanth to do this)</li>
<li>All posible ways an authority can become an adversary from the point of view of other authority (currently one authority can't frame another as an adversary, but maybe is something we would like to add)</li>
</ul>
<a class="header" href="#state-errors" id="state-errors"><h1>State errors</h1></a>
<p>This cover all possible way in which a state verification might fail. If the verification fails the participant sending this state must be considered adversarial (since he signs the gossip containing this state).</p>
<pre><code class="language-rust ignored">pub enum NSVerifyErr {
    // Bad formed triplet. Primary confidence must be equal or greater than secondary confidence.
    // Both confidence must be non negative integers.
    InvalidTriplet,
    // Bls signature provided doesn't match against bls public key + triplet data
    InvalidBlsSignature,
    // Proof doesn't contain enough signatures to increase confidence
    MissingSignatures,
    // Proofs provided are incorrect. Aggregated signature doesn't match with aggregated public keys + triplet data
    InvalidProof,
    // The proof for the current triplet is wrong. Confidence/Outcomes are not valid.
    InconsistentState,
    // There is a proof for a triplet that doesn't require it.
    ExtraProof,
    // Triplet requires a proof that is not present
    MissingProof,
}
</code></pre>
<a class="header" href="#cryptography" id="cryptography"><h1>Cryptography</h1></a>
<p>Participant should sign every message they sent through the network using its public key.</p>
<a class="header" href="#a-hrefhttpsgithubcomexonumexonum_sodiumoxideed25519a" id="a-hrefhttpsgithubcomexonumexonum_sodiumoxideed25519a"><h2><a href="https://github.com/exonum/exonum_sodiumoxide">ed25519</a></h2></a>
<p>This scheme is used to sign gossip in the network layer. This are fast verifiable signatures.</p>
<ul>
<li>Gossips with invalid signatures are discarded</li>
<li>Gossips with valid signatures are processed. If they contain invalid content (deviating from the protocol in anyway), the signature and the content of the gossip is used as evidence for the sender as malicious actor.</li>
</ul>
<a class="header" href="#a-hrefhttpsenwikipediaorgwikibonehe28093lynne28093shachamblsa" id="a-hrefhttpsenwikipediaorgwikibonehe28093lynne28093shachamblsa"><h2><a href="https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham">BLS</a></h2></a>
<p>BLS is used to sign triplets in <a href="Nightshade/Nightshade/Nightshade.html">Nightshade Consensus</a>.</p>
<ul>
<li>Each triplet contain the BLS signature of the holder.</li>
<li>The proof for the triplets are the aggregated signatures of the participants.</li>
<li>Useful because it allow us to run a <a href="https://en.wikipedia.org/wiki/Threshold_cryptosystem">threshold scheme</a>.</li>
<li>Slow signing/verifying. TODO: Link our benchmark.</li>
</ul>
<a class="header" href="#data-structures" id="data-structures"><h1>Data Structures</h1></a>
<p>The following is a list of standard data-structures.</p>
<a class="header" href="#transaction" id="transaction"><h2>Transaction</h2></a>
<pre><code class="language-rust ignored">struct Transaction {
    originator: AccountId,
    receiver: AccountId,
    nonce: u64,
    method_name: Vec&lt;u8&gt;,
    args: Vec&lt;u8&gt;,
    amount: Balance,
}

struct ReceiptBlock {
    header: SignedShardBlockHeader,
    path: Vec&lt;Hash&gt;,
    receipts: Vec&lt;Receipt&gt;,
}
</code></pre>
<a class="header" href="#shard" id="shard"><h2>Shard</h2></a>
<pre><code class="language-rust ignored">struct ShardBlockHeader {
    parent: Hash,
    index: u64,
    shard_id: u64,
    // State trie
    merkle_root_state: Hash,
    // Transactions Trie
    merkle_root_tx: Hash,
    // Receipt blocks Trie
    merkle_root_receipt: Hash,
    // Transaction result Trie
    merkle_root_tx_result: Hash,
    // Receipt result Trie
    merkle_root_receipt_result: Hash,
}

struct tShardBlockBody {
    receipts: Vec&lt;ReceiptBlock&gt;,
    transactions: Vec&lt;SignedTransaction&gt;,
}

struct SignedShardBlock {
    header: ShardHeader,
    body: ShardBody,
    signature: BLS,
    authority_mask: Vec&lt;bool&gt;,
}

// ShardBlock Extra (Index?)
// 	TransactionAddress
// 		BlockId
// 		Index
// 	Receipts
// 		HashMap&lt;ShardId, Vec&lt;Receipt&gt;&gt;
// 	Hash -&gt; Transaction/Receipt Result // or should we put into two Vec that align with transactions/receipts?
// 		Status (Completed, Failed)
// 		Gas
// 		Receipts ids of receipts
// 		Logs


struct ShardClient {
    chain: Chain&lt;SignedShardBlock&gt;,
    runtime: Runtime,
    state: StateDb,
}
    
fn to_shard_receipt_blocks(ShardBlockExtra) -&gt; Vec&lt;ReceiptBlock&gt; { 
   
}
</code></pre>
<a class="header" href="#beacon" id="beacon"><h2>Beacon</h2></a>
<pre><code class="language-rust ignored">//System extension to every contract/account
//	send_money(to, value)
//	swap_keys(old_public_key, new_public_key)
//
//Transaction(orignator=me, receiver=account, method=”system::swap_keys”, args={...})
//
//Transaction(originator=me, receiver=system, method=send_money, args={...})
</code></pre>
<a class="header" href="#mempool" id="mempool"><h1>Mempool</h1></a>
<p>Mempool is responsible for temporarily storing transactions and receipts received from other peers or rpc calls. Nodes in the network reach consensus on payload, which is produced by the mempool. More specifically, nightshade consensus agrees on the hash of a <code>Snapshot</code>, which consists of hashes of transactions and receipts in the mempool.</p>
<p>at the beginning of nightshade consensus, nodes snapshot the mempool content and produce a <code>Snapshot</code>, which consists of hashes of transactions and receipts in the mempool. Then they start to gossip the hash of the snapshot to peers and fetch missing transactions/receipts from peers if necessary. Finally, a consensus is reached on the hash of a snapshot and the block is produced with the transactions and receipts corresponding to the ones in the snapshot.</p>
<a class="header" href="#payload-gossipping-and-fetching" id="payload-gossipping-and-fetching"><h2>Payload Gossipping and Fetching</h2></a>
<p>This sections describes how gossipping works from the perspective of mempool. Mempool gossips <code>ChainPayload</code>, which consists of transactions and receipts, to peers periodically.</p>
<p>The complexity of gossipping arises from snapshot gossipping and fetching. Mempool maintains two containers of snapshots, <code>snapshots</code>, which stores the snapshots that are ready, i.e, the mempool have all the transactions and receipts of the snapshots, and <code>pending_snapshots</code>, which stores the snapshots that mempool have learned from peers but do not yet have the full set of transactions and receipts of.</p>
<p>When consensus starts, mempool would receive<code>BlockProposal</code>, which consists of hash of <code>Snapshot</code>. If it does not know this hash, it would request the snapshot from the peer who sends the block proposal by sending a<code>PayloadSnapshotRequest</code> message. When the mempool receives a <code>Snapshot</code>, it checks whether the snapshot is known to them. If so, the snapshot is added to <code>snapshots</code>.  Otherwise it requests the missing transactions and receipts from the peer who sends the snapshot by sending a <code>MissingPayloadRequest</code> and add the snapshot to <code>pending_snapshots</code>. The snapshot will be moved to <code>snapshots</code> once the mempool receives the response and verifies that the response actually covers the missing parts.</p>
<a class="header" href="#block-production-and-importing" id="block-production-and-importing"><h2>Block Production and Importing</h2></a>
<p>When consensus is reached and a block is being produced, <code>pop_payload_snapshot</code> is called in mempool to remove the snapshot corresponding to the block from <code>snapshots</code>. When a block is imported, mempool removes transactions and receipts in the block.</p>
<a class="header" href="#assumptions" id="assumptions"><h2>Assumptions</h2></a>
<p>We list some assumptions we made about the mempool code.</p>
<p><strong>transactions</strong>: Transactions in mempool are grouped by account id and, within each group, ordered by transaction nonce. When a transaction arrives, mempool checks whether the nonce is feasible, i.e., whether it is larger than the largest known nonce of the account in the last block. If it is not, the transaction is dropped. Mempool then checks whether the transaction signature is valid and drops the transaction if the signature is invalid.</p>
<p><strong>add_missing_payload</strong>: When mempool receives a payload response from peer because it requests missing transactions/receipts in a snapshot, the mempool checks whether the response covers the missing parts, i.e., whether the response is a super set of the missing transactions/receipts.</p>
<p><strong>known_to</strong>: Mempool mains a hashmap of hash to <code>AuthorityId</code> to keep track of what has been sent to which peers. The intention is to reduce the amount of messages sent over the network. When a payload gossip is sent to some peer, mempool adds the hash of transactions and receipts to <code>known_to</code> for that peer and will not send the same transaction/receipt to the peer during future gossipping. Notice that this is intentionally optimistic because if the peer does not receive the message, they will request the missing parts in the future.</p>
<a class="header" href="#block-chain" id="block-chain"><h1>Block Chain</h1></a>
<p>Here we describe how block chain is collectively constructed, the structure of the block chain blocks,
and how these blocks are used by the peers.</p>
<p>As in a classic block chain each block has exactly one parent block and is signed by the validators.
Validators sign the block using BLS signatures only once, i.e. there is no double-signing.
The block can have different states of readiness, depending on the number of signatures and the state of the next block.</p>
<p>To understand the classification of the blocks we need to first see how they are constructed.</p>
<p>Classification of the blocks in the shard chain:</p>
<ul>
<li><strong>Unfinalized block</strong> -- has \( &lt;2N/3 \) signatures. The next block is not allowed to refer to it as a parent;</li>
<li><strong>Semi-finalized block</strong> -- has \( \geq 2N/3 \) signatures but it is not canonical.<br/> The next block is not finished yet.</li>
<li><strong>Finalized</strong> -- when there is \( \geq 2N/3 \) signatures and the block is canonical.<br/>
Other validators have agreed on the given set of signatures,</li>
</ul>
<p>where \( N \) is the number of validators.</p>
<p>The desire to have canonical set of signatures that sign the block and to not have multi-stage consensus
poses engineering difficulties. Specifically a group of validators that work on block X+1 have to agree on the following:</p>
<ol>
<li>Set of transactions that will go into block X+1;</li>
<li>State induced by the transactions of the previous block X (We need to counter adversaries that can produce an invalid state);</li>
<li>Set of signatures that signed transactions included in block X (We want this set to be canonical);</li>
</ol>
<a class="header" href="#construction" id="construction"><h1>Construction</h1></a>
<p>Each validator performs the following tasks:</p>
<ol>
<li>Collects transactions by accepting incoming transactions from the peers and through the gossip from the validators;</li>
<li>Runs consensus with other validators to agree on a set of transactions that will be used for the block.
The consensus also includes agreeing on the previous state see (3), and the previous set of signatures see (4);</li>
<li>Computes the new state from the set of transactions and the previous state;</li>
<li>Collects BLS signatures for the given block.</li>
</ol>
<a class="header" href="#the-challenges" id="the-challenges"><h2>The challenges</h2></a>
<p>We want our block chain to have the following properties that make the design challenging:</p>
<ol>
<li>Each block is signed only once by a BLS signature;</li>
<li>BLS signature of the given block is canonical
(Recall, that the block is valid when it is signed by \( &gt; 2N/3 \) validators. However, in a general block chain,
this set of validators does not have to be the same as known by the peers in the network. In our design we want this
set to be canonical, i.e. agreed upon by the network, and therefore unique.);</li>
<li>Each block is self-contained, i.e. we do not need to have another block to verify it.</li>
</ol>
<a class="header" href="#the-invariant" id="the-invariant"><h2>The invariant</h2></a>
<p>The general invariant for most of the PoS block chains, is that for transactions to be incorporated into a block chain
the following must be performed:</p>
<ul>
<li>The transactions are collected;</li>
<li>The transactions are executed;</li>
<li>The set of transactions is agreed on through a consensus;</li>
<li>The execution result is agreed on through a consensus.</li>
</ul>
<p>Additionally, as discussed in the previous section, we want the following:</p>
<ul>
<li>The set of BLS parts that sign the given block is agreed on through a consensus.</li>
</ul>
<p>In our design, the set of transactions, the execution result (the new state), and the BLS parts are agreed on
simultaneously through a single consensus.
Specifically, the consensus agrees on the following:</p>
<ul>
<li>Set of transactions for block \( X + 1 \);</li>
<li>Execution result of the transactions from the block \( X \);</li>
<li>BLS parts of block \( X \) .</li>
</ul>
<a class="header" href="#the-state-machine" id="the-state-machine"><h2>The state machine</h2></a>
<p>The block chain logic of a validator is implemented as a state-machine with three &quot;states&quot;:</p>
<ol>
<li>Collecting transactions for block \( X + 1 \);</li>
<li>Computing state from transactions of block \( X \) and continuing collecting transactions for block \( X + 1 \);</li>
<li>Running consensus to agree on a set of transactions for block \( X + 1\) .</li>
</ol>
<p>(1) is initiated when the validator receives the announcement of the block \( X - 1 \);<br/>
(2) is initiated when the validator receives the announcement of the block \( X \);<br/>
(1) + (2) terminate and (3) is initiated when the state computation is finished;<br/>
(3) terminates when the consensus is finished.<br/></p>
<p>See the flow diagram and the state machine diagram below:
<img src="../img/block_production.jpg" /></p>
<p>Interestingly, the transaction collection state has nuances. Specifically, transaction collection happens passively
through the maintenance of a mempool the collects transactions. While a newly-joining validator that wants to build
block \( X \) has to start collecting transactions when it gets announcement of block \( X - 2 \), the validator
that was already building block \( X \) will collect transactions only during its state (3) while building consensus.</p>
<a class="header" href="#submitting-transactions" id="submitting-transactions"><h2>Submitting transactions</h2></a>
<p>The user that wants to send a transactions must then send it to validators that are currently in state (1) or (2) by
anticipating when they might have received the corresponding block announcements and started listening to transactions.</p>
<a class="header" href="#block-structure" id="block-structure"><h1>Block Structure</h1></a>
<p>The following code explains how each block is structured:</p>
<pre><code class="language-rust ignored">struct Block {
    parent_hash: CryptoHash,
    /// State computed from the transations and the state in the parent block.
    parent_state: State,
    /// A canonical set of signatures signing `transactions`
    /// and `parent_state` of the parent block.
    parent_signatures: BLSAggregate,
    transactions: Transactions,
}

struct SignedBlock {
    block: Block,
    /// A non-canonical set of signatures that verifies `block` but is subject
    /// to change until the next block is constructed.
    signatures: BLSAggregate,
}
</code></pre>
<p>Each <code>SignedBlock</code> can then be of three types:</p>
<ul>
<li><code>Unfinalized</code> -- the number of <code>signatures</code> is \( &lt; 2N/3 \).
This state only exists for the blocks on the beacon chain, where we allow temporary forks;</li>
<li><code>Semi-finalized</code> -- the number of <code>signatures</code> is \( \geq 2N/3 \) but the parent block is missing,
which means <code>signatures</code> is subject to change since they are agreed on in the next block;</li>
<li><code>Finalized</code> -- the number of <code>signatures</code> is \( \geq 2N/3 \) and the parent block is known.
For beacon chain the number of signatures can be \( &lt; 2N/3 \) but the parent block should be known.</li>
</ul>
<p>The shard-chain is therefore always looks like this:</p>
<div class="mermaid">
graph LR
    id0(Finalized block X-3)-->id1
    id1(Finalized block X-2)-->id2
    id2(Finalized block X-1)-->id3(Semi-finalized block X)
    style id0 fill:#f9f,stroke:#333,stroke-width:4px
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#f9f,stroke:#333,stroke-width:4px
    style id3 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5
</div>
<p>While beacon-chain can also look like this, for a brief moment while resolving a fork:</p>
<div class="mermaid">
graph LR
    id0(Finalized block X-3)-->id1
    id1(Finalized block X-2)-->id2
    id2(Finalized block X-1)-->id3(Unfinalized block X)
    style id0 fill:#f9f,stroke:#333,stroke-width:4px
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#f9f,stroke:#333,stroke-width:4px
    style id3 fill:#ccf,stroke:#f66,stroke-width:0px
</div>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p><code>SignedBlock</code> is mostly used for the network exchange, for the situations when a catching-up peer requests a single block.
<code>SignedBlock</code> is also used for block announcements.</p>
<p><code>Block</code> is used for when a peer requests a range of \( m \) blocks (we then return \( m - 1\) <code>Block</code>'s and one <code>SignedBlock</code>).
<code>Block</code> is also used for internal representation of the chain and the storage.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        
        <script type="text/javascript" src="mermaid.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
